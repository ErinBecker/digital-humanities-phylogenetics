dtm_df$num_entries = rowSums(dtm_df)
dtm_df["num_occurances",] = colSums(dtm_df)
dtm_df["num_occurances","num_entries"] = NA
plot(density(dtm_df$num_entries, na.rm = TRUE))
table(dtm_df$num_entries) #number of documents with each number of entries
length(which(dtm_df$num_entries >= 10))
length(which(dtm_df$num_entries >= 100))
setwd("Box Sync/digital-humanities-phylogenetics/data")
getwd()
setwd("../data")
dtm_df = read.table("dtm_df.csv", sep = ",", header = TRUE, row.names = 1)
dtm_df$num_entries = rowSums(dtm_df)
dtm_df["num_occurances",] = colSums(dtm_df)
dtm_df["num_occurances","num_entries"] = NA
plot(density(dtm_df$num_entries, na.rm = TRUE))
table(dtm_df$num_entries) #number of documents with each number of entries
?table
?"["
head(dist(iris[, 3:4])
)
str(iris)
?dist
#install.packages("ggdendro")
install.packages("ggdendro")
library(ggdendro)
?read.table
unique(iris$Species)
stuff = c("pig", "cow", "horse", "snake", "bunny")
plot(c(1:5))
plot(c(1:5), pch = stuff)
plot(c(1:5), pch = as.factor(stuff))
plot.new()
plot.window(xlim=c(1,10), ylim=c(1,10))
text(x=1:10, y=1:10, labels="Hallo")
?text
text(x = 1:5, y = 1:5, labels = stuff)
text(x = 1:5, y = 1:5, labels = stuff)
plot.new()
plot.window(xlim=c(1,10), ylim=c(1,10))
text(x = 1:5, y = 1:5, labels = stuff)
plot.new()
plot.window(xlim=c(1,10), ylim=c(1,10))
text(x = 1:5, y = 1:5, labels = stuff, cex = 0.5)
source('~/Google Drive (erinstellabecker@gmail.com)/SWC-DC/InstructorTraining/Strategy_for_instructor_training/Email-scripts/sendmail_certificates_sep.R', echo=TRUE)
knitr::opts_chunk$set(echo = TRUE)
requests = read.csv("../data/training-data/training_requests_2017-04-05.csv")
requests = read.csv("../data/training-data/training_requests_2017-04-05.csv")
str(requests)
summary(requests)
requests = read.csv("../data/training-data/training_requests_2017-04-05.csv")
table(requests$Expertise.areas)
library("digest", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("digest", lib.loc="~/Library/R/3.3/library")
install.packages("digest", lib="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
.libPaths()
library(ggplot2)
library(ggplot)
library("ggplot2", lib.loc="~/Library/R/3.3/library")
install.packages("ggplot2")
library(ggplot2)
library("ggplot2", lib.loc="~/Library/R/3.3/library")
install.packages("ggplot2", lib="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(ggplot2)
from ggplot import *
ggplot(aes(x='date', y='beef'), data=meat) +\
geom_line() +\
stat_smooth(colour='blue', span=0.2)
ggplot(aes(x='date', y='beef'), data=meat) +
geom_line() +
stat_smooth(colour='blue', span=0.2)
install.packages("ggplot2")
source('~/.active-rstudio-document', echo=TRUE)
install.packages("ggplot2")
str(cars)
str(iris)
head(iris)
dc_instructors <- read.csv("https://data.softwarecarpentry.org/api/queries/13/results.csv?api_key=b53f027922fce082075a859bc0a2fba8b20bb986", stringsAsFactors = FALSE)
applicants <- read.csv("/Users/ebecker/Downloads/training_requests.csv", stringsAsFactors = FALSE)
applicants <- applicants[applicants$State == "Pending",]
applicants <- applicants[applicants$Matched.Trainee == "—",]
unaffiliated_tags = c("", "N/A", "n/a", "na", "NA", "None", "none", "Independent", "independent",
"unaffiliated", "Unaffiliated", "individual", "Individual")
applicants <- applicants[applicants$Group.Name %in% unaffiliated_tags,]
previous_applicants_file = "/Users/ebecker/Box Sync/Carpentry_repos/private_data/previous_TTT_applicants.txt"
previous_applicants = read.csv(previous_applicants_file)
applicants <- read.csv("/Users/ebecker/Downloads/training_requests.csv", stringsAsFactors = FALSE)
applicants <- applicants[applicants$State == "Pending",]
applicants <- applicants[applicants$Matched.Trainee == "—",]
unaffiliated_tags = c("", "N/A", "n/a", "na", "NA", "None", "none", "Independent", "independent",
"unaffiliated", "Unaffiliated", "individual", "Individual")
applicants <- applicants[applicants$Group.Name %in% unaffiliated_tags,]
previous_applicants_file = "/Users/ebecker/Box Sync/Carpentry_repos/carpentry-private-data/instructor-assessment/data/training-data/previous_TTT_applicants.txt"
previous_applicants = read.csv(previous_applicants_file)
applicants = applicants[!applicants$Email %in% previous_applicants$Email,]
previous_applicants_file = "/Users/ebecker/Box Sync/Carpentry_repos/carpentry-private-data/instructor-assessment/data/training-data/previous_TTT_applicants.txt"
previous_applicants = read.csv(previous_applicants_file)
applicants = applicants[!applicants$Email %in% previous_applicants$Email,]
View(applicants)
library(gmailr)
mail_applicants = function(data) {
for (i in 1:nrow(data)) {
name = paste0(data$Personal[i], ",")
address = data$Email[i]
to = address
from = "ebecker@carpentries.org"
subject = "Thank you for your application to become a Data or Software Carpentry instructor"
body = paste("Hi", name, "\n\nThank you for applying for Software and Data Carpentry’s Instructor Training program. We’re excited to have you as part of our community.\n
We receive hundreds of applications, and we cannot provide no-cost training for every applicant. Please, don't let that discourage you! We'd like to help you bring workshops and instructor training to your organization. We’re working on ways to increase our capacity to offer trainings to individuals not affiliated with member institutions, and hope to be able to offer more of these trainings soon. Your application has been placed on our waiting list while we grow our capacity.
If you’d like to become a member, get in touch with memberships@carpentries.org to learn more about how we can help you make the case at your organization. In the meantime, please get involved!
- Join our discussion email list (http://lists.software-carpentry.org/listinfo/discuss)
- Follow us on Twitter (@datacarpentry and @swcarpentry)
- Contribute to lesson development (http://www.datacarpentry.org/involved-lessons/)
- Find a local workshop (http://www.datacarpentry.org/workshops-upcoming/ or https://software-carpentry.org/workshops/)
Learn more about us!
- Read our blogs (http://www.datacarpentry.org/blog/ and https://software-carpentry.org/blog/)
- Sign-up for our newsletter (https://tinyurl.com/mwn8ad3) and read past issues (https://tinyurl.com/kft7j7e)
Most of our instructor training events are offered as part of institutional memberships and Member organizations receive training priority. To fast-track your application, consider becoming a Member. For more information see: https://software-carpentry.org/scf/join/ and http://www.datacarpentry.org/partnerships/.
If you have questions about your application, please contact admin@datacarpentry.org. Thanks again for applying!
Best,
Erin Becker")
# Construct message
mime() %>%
from(from) %>%
to(to) %>%
subject(subject) %>%
html_body(body) %>%
attach_part(body) -> msg
send_message(msg)
# add email to previous_applicants
cat(paste0("\n", address), file = previous_applicants_file, append = TRUE)
}
}
mail_applicants(applicants)
applicants <- read.csv("/Users/ebecker/Downloads/training_requests.csv", stringsAsFactors = FALSE)
applicants <- applicants[applicants$State == "Pending",]
applicants <- applicants[applicants$Matched.Trainee == "—",]
unaffiliated_tags = c("", "N/A", "n/a", "na", "NA", "None", "none", "Independent", "independent",
"unaffiliated", "Unaffiliated", "individual", "Individual")
applicants <- applicants[applicants$Group.Name %in% unaffiliated_tags,]
previous_applicants_file = "/Users/ebecker/Box Sync/Carpentry_repos/carpentry-private-data/instructor-assessment/data/training-data/previous_TTT_applicants.txt"
previous_applicants = read.csv(previous_applicants_file)
applicants = applicants[!applicants$Email %in% previous_applicants$Email,]
library(gmailr)
mail_applicants = function(data) {
for (i in 1:nrow(data)) {
name = paste0(data$Personal[i], ",")
address = data$Email[i]
to = address
from = "ebecker@carpentries.org"
subject = "Thank you for your application to become a Data or Software Carpentry instructor"
body = paste("Hi", name, "\n\nThank you for applying for Software and Data Carpentry’s Instructor Training program. We’re excited to have you as part of our community.\n
We receive hundreds of applications, and we cannot provide no-cost training for every applicant. Please, don't let that discourage you! We'd like to help you bring workshops and instructor training to your organization. We’re working on ways to increase our capacity to offer trainings to individuals not affiliated with member institutions, and hope to be able to offer more of these trainings soon. Your application has been placed on our waiting list while we grow our capacity.
If you’d like to become a member, get in touch with memberships@carpentries.org to learn more about how we can help you make the case at your organization. In the meantime, please get involved!
- Join our discussion email list (http://lists.software-carpentry.org/listinfo/discuss)
- Follow us on Twitter (@datacarpentry and @swcarpentry)
- Contribute to lesson development (http://www.datacarpentry.org/involved-lessons/)
- Find a local workshop (http://www.datacarpentry.org/workshops-upcoming/ or https://software-carpentry.org/workshops/)
Learn more about us!
- Read our blogs (http://www.datacarpentry.org/blog/ and https://software-carpentry.org/blog/)
- Sign-up for our newsletter (https://tinyurl.com/mwn8ad3) and read past issues (https://tinyurl.com/kft7j7e)
Most of our instructor training events are offered as part of institutional memberships and Member organizations receive training priority. To fast-track your application, consider becoming a Member. For more information see: https://software-carpentry.org/scf/join/ and http://www.datacarpentry.org/partnerships/.
If you have questions about your application, please contact admin@datacarpentry.org. Thanks again for applying!
Best,
Erin Becker")
# Construct message
mime() %>%
from(from) %>%
to(to) %>%
subject(subject) %>%
html_body(body) %>%
attach_part(body) -> msg
send_message(msg)
# add email to previous_applicants
cat(paste0("\n", address), file = previous_applicants_file, append = TRUE)
}
}
source('~/.active-rstudio-document', echo=TRUE)
install.packages("XLConnect")
source('~/.active-rstudio-document', echo=TRUE)
Q1_sections = read.csv("Q000001_sections.csv")
setwd("/Users/ebecker/Box Sync/digital-humanities-phylogenetics/data/composite_texts/")
Q1_sections = read.csv("Q000001_sections.csv")
Q1_sections = read.csv("Q000001_sections.csv", stringsAsFactors = FALSE)
Q39_sections = read.csv("Q000039_sections.csv", stringsAsFactors = FALSE)
Q40_sections = read.csv("Q000040_sections.csv", stringsAsFactors = FALSE)
Q41_sections = read.csv("Q000040_sections.csv", stringsAsFactors = FALSE)
Q42_sections = read.csv("Q000042_sections.csv", stringsAsFactors = FALSE)
ob_lists_wood_w_id_text = read.csv("../ob_lists_wood_w_id_text.csv")
ob_lists_wood_w_id_text$X = NULL
# make df to store results
doc_list = unique(ob_lists_wood_w_id_text$id_text)
section_names = colnames(Q39_sections)
section_matrix = data.frame(sapply(doc_list, function(x) x = logical(length(section_names))), row.names = section_names)
colnames(section_matrix) = doc_list
doc_list = as.character(doc_list)
for (j in unique(doc_list)) {
entries = as.character(ob_lists_wood_w_id_text[which(ob_lists_wood_w_id_text$id_text == j),]$entry)
for (i in 1:ncol(Q39_sections)) {
presence = sum(Q39_sections[,i] %in% tolower(entries))
#    if (presence > 0) presence = 1
section_matrix[i, j] = presence
}
section_matrix
}
section_matrix$section_name = row.names(section_matrix)
# Put data into form that can be plotted by geom_tile in ggplot2
#install.packages("reshape")
library(reshape)
melted_df = melt(section_matrix)
head(melted_df)
melted_df_binary = melted_df
for (i in 1:nrow(melted_df_binary)) {
if (melted_df_binary$value[i] > 0) melted_df_binary$value[i] = 1
}
library(ggplot2)
ggplot(data = melted_df, aes(y = variable, x = section_name)) +
geom_tile(aes(fill = value)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
qplot(data = melted_df_binary, x = section_name, y = variable, fill = factor(value),
geom = "tile") + scale_fill_manual(values = c("0"="lightblue", "1" = "red")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
doc_list = unique(ob_lists_wood_w_id_text$id_text)
section_names = colnames(Q39_sections)
section_matrix = data.frame(sapply(doc_list, function(x) x = logical(length(section_names))), row.names = section_names)
colnames(section_matrix) = doc_list
doc_list = as.character(doc_list)
for (j in unique(doc_list)) {
entries = as.character(ob_lists_wood_w_id_text[which(ob_lists_wood_w_id_text$id_text == j),]$entry)
for (i in 1:ncol(Q39_sections)) {
presence = sum(Q39_sections[,i] %in% tolower(entries))
#    if (presence > 0) presence = 1
section_matrix[i, j] = presence
}
section_matrix
}
section_matrix$section_name = row.names(section_matrix)
library(reshape)
melted_df = melt(section_matrix)
head(melted_df)
melted_df_binary = melted_df
for (i in 1:nrow(melted_df_binary)) {
if (melted_df_binary$value[i] > 0) melted_df_binary$value[i] = 1
}
library(ggplot2)
ggplot(data = melted_df, aes(y = variable, x = section_name)) +
geom_tile(aes(fill = value)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
qplot(data = melted_df_binary, x = section_name, y = variable, fill = factor(value),
geom = "tile") + scale_fill_manual(values = c("0"="lightblue", "1" = "red")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
install.packages("ggdendro", "/anaconda/lib/R/library")
install.packages("ggplot2", "/anaconda/lib/R/library")
install.packages("ggplot2", "/anaconda/lib/R/library")
install.packages("ggplot2", "/anaconda/lib/R/library")
install.packages("ggplot2", "/anaconda/lib/R/library")
?library
library(ggplot2)
ggplot(data = melted_df, aes(y = variable, x = section_name)) +
geom_tile(aes(fill = value)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
qplot(data = melted_df_binary, x = section_name, y = variable, fill = factor(value),
geom = "tile") + scale_fill_manual(values = c("0"="lightblue", "1" = "red")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
# Use getLongestCommonSubstring() from Rlibstree
# source("http://bioconductor.org/biocLite.R")
# biocLite("Rlibstree")
# Needs bioconductor and having difficulty installing on Jupyter notebook
# Want to test and make sure it works before I go through all the trouble
setwd("/Users/ebecker/Box Sync/digital-humanities-phylogenetics/data/composite_texts/")
## Functions
get_guidewords = function(line) {
# extract all guidewords for an entry into character vector
line = unlist(strsplit(line, "_"))
line = gsub(".*\\[", "", line)
line = gsub("\\].*", "", line)
line = gsub("~", "", line)
guidewords = line
guidewords = guidewords[which(guidewords != "na")]
guidewords
}
get_citation_forms = function(line) {
# extract all citation forms for an entry into character vector
line = unlist(strsplit(line, "_"))
line = gsub("(.*)\\[.*", "\\1", line)
citation_form = line
citation_form = citation_form[which(citation_form != "na")]
citation_form
}
clean_kmer = function(x) {
# get rid of part of speech (follows each ])
#  x = gsub("(\\])[a-zA-Z/]*_", paste0("\\1", "_"), x) #for all but last word
x = gsub("(\\])[a-zA-Z/]*", "\\1", x) #for all but last word
#  x = gsub("(_.*\\])[a-zA-Z/]*", "\\1", x) #for last word
# get rid of punctuation (but only {}[]_.)
x = gsub("\\]", "", x)
x = gsub("\\[", "", x)
x = gsub("\\{", "", x)
x = gsub("\\}", "", x)
x = gsub("_", "", x)
x = gsub("\\.", "", x)
x = gsub("~", "", x)
x
}
def_section_breaks = function(df, cutoff) {
# a section ends anytime overlap is zero and k is below the defined cutoff
df$section = NA
sect_num = 1
first_section_start = which(df$overlap > 0 | df$k >= cutoff)[1]
df$section[first_section_start] = sect_num
section_break = FALSE
for (i in (first_section_start):nrow(df)) {
if (df$overlap[i] > 0 | df$k[i] >= cutoff) {
if (section_break == TRUE) { sect_num = sect_num + 1 }
df$section[i] = sect_num
section_break = FALSE
}
else {
df$section[i] = NA
section_break = TRUE
}}
df
}
extract_sections = function(df, file) {
# writes all entries present in each section to a file
section_nums = unique(df$section[!is.na(df$section)])
sections = data.frame(sapply(section_nums, function(x) x = character(max(table(df$section)) + 1)))
for (i in section_nums) {
elements = unique(c(df[which(df$section == i),]$line_a, df[which(df$section == i),]$line_b))
missing = max(table(df$section) + 1) - length(elements)
elements = c(elements, rep(NA, missing))
sections[,i] = elements
colnames(sections)[i] = paste(get_guidewords(sections[1,i]), collapse = "_")
}
write.csv(sections, file, row.names = FALSE, quote = FALSE)
}
compare_entries = function(infile, cutoff, outfile) {
name = strsplit(infile, "\\.")[[1]][1]
df_composite = read.csv(infile, stringsAsFactors = FALSE)
# remove lines in df representing missing lines or sections
empty_lines = which(df_composite$entry == "")
if (length(empty_lines) != 0) {df_composite = df_composite[-empty_lines,] }
# initialize empty data frame for storing results
num_rows = nrow(df_composite) - 1
df_compare = data.frame(line_a = character(num_rows),
line_b = character(num_rows),
overlap = numeric(num_rows),
kmer = character(num_rows),
k = numeric(num_rows),
stringsAsFactors = FALSE)
for (i in 1:nrow(df_composite) - 1) {
line_a = tolower(df_composite$entry[i])
guidewords_a = get_guidewords(line_a)
citation_form_a = get_citation_forms(line_a)
line_b = tolower(df_composite$entry[i + 1])
guidewords_b = get_guidewords(line_b)
citation_form_b = get_citation_forms(line_b)
line_a_clean = clean_kmer(line_a)
line_b_clean = clean_kmer(line_b)
kmer = getLongestCommonSubstring(c(line_a_clean, line_b_clean))
kmer = gsub("[\x80-\xFF]", "", kmer) # get rid of multibyte strings introduced by Rlibstree
k = nchar(kmer)
if (length(kmer) == 0) {
kmer = NA
k = 0 }
overlap = sum(citation_form_a %in% citation_form_b) + sum(guidewords_a %in% guidewords_b)
df_compare$line_a[i] = line_a
df_compare$line_b[i] = line_b
df_compare$overlap[i] = overlap
df_compare$kmer[i] = kmer
df_compare$k[i] = k
}
plot(df_compare$overlap, pch = ".", main = name, ylab = "# matching words", xlab = "line number")
df_compare = def_section_breaks(df_compare, cutoff = cutoff)
plot(table(df_compare$section), main = name, ylab = "# entries in section", xlab = "section")
#  extract_sections(df_compare, outfile)
df_compare
}
####### Get section members and write to file #######
#
Q1 = compare_entries("Q000001.csv", cutoff = 3, "Q000001_sections.csv")
Q39 = compare_entries("Q000039.csv", cutoff = 3, "Q000039_sections.csv")
Q40 = compare_entries("Q000040.csv", cutoff = 3, "Q000040_sections.csv")
Q41 = compare_entries("Q000041.csv", cutoff = 3, "Q000041_sections.csv")
Q42 = compare_entries("Q000042.csv", cutoff = 3, "Q000042_sections.csv")
######################################################
####### Read in section definitions from file #######
Q1_sections = read.csv("Q000001_sections.csv", stringsAsFactors = FALSE)
Q39_sections = read.csv("Q000039_sections.csv", stringsAsFactors = FALSE)
Q40_sections = read.csv("Q000040_sections.csv", stringsAsFactors = FALSE)
Q41_sections = read.csv("Q000040_sections.csv", stringsAsFactors = FALSE)
Q42_sections = read.csv("Q000042_sections.csv", stringsAsFactors = FALSE)
####### Read in documents dealing with trees and wooden objects #######
ob_lists_wood_w_id_text = read.csv("../ob_lists_wood_w_id_text.csv")
ob_lists_wood_w_id_text$X = NULL
# make df to store results
doc_list = unique(ob_lists_wood_w_id_text$id_text)
section_names = colnames(Q39_sections)
section_matrix = data.frame(sapply(doc_list, function(x) x = logical(length(section_names))), row.names = section_names)
colnames(section_matrix) = doc_list
doc_list = as.character(doc_list)
for (j in unique(doc_list)) {
entries = as.character(ob_lists_wood_w_id_text[which(ob_lists_wood_w_id_text$id_text == j),]$entry)
for (i in 1:ncol(Q39_sections)) {
presence = sum(Q39_sections[,i] %in% tolower(entries))
#    if (presence > 0) presence = 1
section_matrix[i, j] = presence
}
section_matrix
}
section_matrix$section_name = row.names(section_matrix)
# Put data into form that can be plotted by geom_tile in ggplot2
#install.packages("reshape")
library(reshape)
melted_df = melt(section_matrix)
head(melted_df)
melted_df_binary = melted_df
for (i in 1:nrow(melted_df_binary)) {
if (melted_df_binary$value[i] > 0) melted_df_binary$value[i] = 1
}
library(ggplot2)
ggplot(data = melted_df, aes(y = variable, x = section_name)) +
geom_tile(aes(fill = value)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
qplot(data = melted_df_binary, x = section_name, y = variable, fill = factor(value),
geom = "tile") + scale_fill_manual(values = c("0"="lightblue", "1" = "red")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3), axis.text.y = element_text(size = 3))
